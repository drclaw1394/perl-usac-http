#!/usr/bin/env perl
use v5.36;
our $VERSION="v0.1.0";

use feature qw<try>;
no warnings "experimental";

use Log::ger;
use Log::ger::Output "Screen";
use Log::OK {
	lvl=>"info",
	opt=>"verbose",
};

use EV;
use AnyEvent;

use Import::These qw<uSAC:: Util ::HTTP:: Server ::Middleware:: Static Log>;


use Getopt::Long;
Getopt::Long::Configure("pass_through");

my %options;
my $verbose=0;

$options{quiet}=sub { $verbose=0 };
$options{verbose}=\$verbose;


# inject a site with prefix. any routes mounted after will use this prefix
# --site
# --site "prefix=0";
# --site "id=df,prefix=23"

sub parse_site_spec{
  my $input=$_[0];
  my @full=qw<id prefix>;
  my %spec;
  for my $field(split ",", $input){
    unless($field=~/=/){
      #Assume only a site name, with empty prefix
      $spec{id}=$field;
      next;
    }
    for my ($key,$value)(split "=", $field, 2){
      #say $key;
      #say $value;
			$key=~s/ //g;
			$value=~s/ //g;
			my @val;

			#Ensure only 0 or 1 keys match
			die "Ambiguous field name: $key" if 2<=grep /^$key/i, @full;

      # Find the first item that starts with the shorthand
			($key)=grep /^$key/i, @full;
      $spec{$key}=$value;
    }
  }
  \%spec;
}

my @staging;

GetOptions \%options,
  # Help
	"help",
  "site=s"=>sub { 
    push @staging, parse_site_spec($_[1]);
    
  },

  # Filter arguments, to push file names into staging
  "<>"=>sub {
  say join ", ", @_;
      push @staging, $_[0];
  },
  
  # Listener
	"listen=s@",

  # Static file options
	"list-dir!",		#serve html rendered dir list from this location
  "read-size=i",
  "indexes=s@",


  # Log
	"log",

	"host=s@",
	"product=s",
	"ws=s%", 		#connect to uri (unix:// tcp:// udp:// ws:// file://) and just spit the information 

	"mime-add=s%",		#Specifiy a mime type mapping for an extension, add to list
	"mime=s%",		#Specifiy a file containing a list of mime types
				#on a websocket
	"quiet",		#quiet flag
	"watch",		#watch changes to input files, and relauch
	"verbose",


	or do {
    require Pod::Usage;
    Pod::Usage::pod2usage(verbose=>1);
  };


# default static files from the current directory
$options{"listen"}//=["[::]:8000"];


if($options{help}){
  require Pod::Usage;
  Pod::Usage::pod2usage(verbose=>2);
}


# Welcome
my $welcome= "uSAC HTTP Server $VERSION - Copyright 2023 Ruben Westerberg
";
Log::OK::INFO and log_info $welcome;



# Create server
#
my $server=uSAC::HTTP::Server->new(listen=>$options{listen});


# Inject logging if logging enabled
#
$server->add_middleware( uhm_log dump_headers=>1, color=>1) if $options{log};

my %sites;
$sites{"/"}=$server;

my $current=$server;
say "staging";
use Data::Dump::Color;
for(@staging){
  dd $_;
  if(ref($_) eq "HASH"){

    # look up site spec by id, reuse site if found 
    # otherwise new anonimous site added to current
    my $new=$_->{id}?$sites{$_->{id}}:undef;
    unless($new){
      say "Id from spec: $_->{id}";
      dd $_;
      $sites{$_->{id}}=$new=uSAC::HTTP::Site->new($_->%*);
      $current->add_site($new);
    }
    $current=$new;
    say "id".$current->id;
    say "prefix: ".$current->prefix;
    say "built prefix: ".$current->built_prefix;
  }
  else {
    # Treat as path to file or dir
    #convert to abs for intended behaviour	
    my $target=uSAC::Util::rel2abs($_, uSAC::Util::cwd);

    if(/\.psgi$/i){
      # Add explicit PSGI middleware with path to application
      # uses site prefix  for mounting
      #
      Log::OK::INFO and log_info "Loading PSGI from source:\n $target";
      require uSAC::HTTP::Middleware::PSGI;
      $current->add_route("", uSAC::HTTP::Middleware::PSGI::uhm_psgi($_));
    }
    elsif(/\.route$|\.pl$/){
      Log::OK::INFO and log_info "Loading Routes from source:\n $target";
      # perl script to run as  
      $current->load($target);
    }
    else {
      # Assume a dir for serving static files from
      Log::OK::INFO and log_info "Serving static files from source:\n $target";
      $current->add_route("", uhm_static_root roots=>[$_],
        list_dir  =>  $options{"list-dir"},
        read_size =>  $options{"read-size"},
        indexes   =>  $options{indexes},
      );
    }
  }
}

# Configure
my @options=@ARGV;
push @options, "--show";
$server->parse_cli_options(@options);

# Run!
$server->run();
