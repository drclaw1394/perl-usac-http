#!/usr/bin/env perl
use strict;
use warnings;
use version; our $VERSION=version->declare("v0.1");
use feature qw<say>;

use Log::ger;
use Log::ger::Output "Screen";
use Log::ger::Util;
use Log::OK {
	lvl=>"info",
	opt=>"verbose",
};

Log::ger::Util::set_level Log::OK::LEVEL;



use Data::Dumper;
use File::Spec::Functions qw<rel2abs>;
use File::Basename qw<dirname basename>;
use Cwd;

#usac-http server command line utility
use uSAC::HTTP;
use uSAC::HTTP::Server;
use uSAC::HTTP::Static;
use uSAC::HTTP::Middleware qw<log_simple>;


use Getopt::Long;
my %options;
my $verbose=0;
$options{quiet}=sub {$verbose=0};
$options{verbose}=\$verbose;
GetOptions \%options,
	"hosts=s@",
	"listen=s@",
	"product=s",
	"preclude=s@",
	"postclude=s@",
	"www-root=s@"	,	#serve files from this location
	"list-dir",		#serve html rendered dir list from this location
	"ws=s%", 		#connect to uri (unix:// tcp:// udp:// ws:// file://) and just spit the information 
	"mime-add=s%",		#Specifiy a mime type mapping for an extension, add to list
	"mime=s%",		#Specifiy a file containing a list of mime types
				#on a websocket
	"route=s%",		#url to named sub 		GET, URI, SUB
	"route-do=s%",		#url to a single pl file	METHOD, URI, FILE
	"quiet",		#quiet flag
	"watch",		#watch changes to input files, and relauch
	"verbose",
	"log",



	or die "problem with command line arguments";


# TODO:
#	--ws my/uri=file://file_to_watch
#	--ws my/ws=unix://named_fifo
#	--ws my/bridge=tcp://host:port
#	--ws my/bridge=udp://host:port
#	--ws my/bridge=http://host:port/path		#will hammer the destination if not long poll
#
#	--mqtt my/url=>mqtt://host:port/topic		#subscribes to a topic and pushes the newest
#							#message out to incomming connections.
#							#if accept is multipart then mutiple messages	

# Currently Working on:
#	--static-file /prefix=path_to_dir_with_static_files
#	--static-dir /prefix=path_to_dir_list		#uses accepts to determing format
#		
#
#create server instance;
#load any config file specified

#set default listener if non provided
$options{listen}//=["0.0.0.0:8080"];

my $welcome="uSAC Server version $VERSION";
Log::OK::INFO and log_info $welcome;



my $server;
$server=usac_server{
	#set the sub product
	usac_middleware log_simple dump_headers=>1 if $options{log};
	#add all listeners
	my $listeners=$options{listen};
	for my $listener (@$listeners){
		Log::OK::INFO and log_info "Listening on $listener";
		usac_listen no_hosts=>1, $listener;
		#"127.0.0.1:8080";
				
	}
	usac_sub_product "test";

	#add additional files
	my $includes=$options{preclude};
	for my $include (@$includes){
		#convert to abs for intended behaviour	
		my $target=rel2abs($include,getcwd);
		Log::OK::INFO and log_info "Including config from source:\n $target";
		usac_include $target;
	}

	usac_site {
		#add the hosts we respond to (add all listeners)
		usac_id "test";
		#usac_host "localhost:8080";
		#usac_host "127.0.0.1:8080";

		#add additional files
		my $hosts=$options{hosts};
		for my $host (@$hosts){
			Log::OK::INFO and log_info "Virtual host $host";
			usac_host $hosts;
		}
		unless(@$hosts){
			Log::OK::WARN and log_warn "No virtual host setup. Accepting for any host";
		}

		#add the routes
		#usac_route "/static/$File_Path" => usac_file_from "../data";

                #add static file routes
                my $static=$options{"www-root"};
		my @roots;
                for my $s (@$static){
			Log::OK::INFO and log_info "Serving files from: $s Listing dir: ".($options{"list_dir"}?"yes":"no");


                        push @roots, usac_file_under list_dir=>$options{"list-dir"}, $s;
                } 
		usac_route ["GET","HEAD"],"/", @roots;

		#TODO: fix dir listing so it can be chainable


	};

	#add additional files
	$includes=$options{postclude};
	for my $include (@$includes){
		#convert to abs for intended behaviour	
		my $target=rel2abs($include,getcwd);
		Log::OK::INFO and log_info "Including config from source: $target";
		usac_include $target;
	}
};

$server->run();
